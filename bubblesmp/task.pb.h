// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: task.proto

#ifndef PROTOBUF_task_2eproto__INCLUDED
#define PROTOBUF_task_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "bubblesmp/index.pb.h"
#include "bubblesmp/environment/environment.pb.h"
#include "bubblesmp/generators/generator.pb.h"
// @@protoc_insertion_point(includes)

namespace com {
namespace ademovic {
namespace bubblesmp {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_task_2eproto();
void protobuf_AssignDesc_task_2eproto();
void protobuf_ShutdownFile_task_2eproto();

class Point;
class TreeConfig;
class TaskConfig;

enum TreeConfig_Type {
  TreeConfig_Type_BUBBLE = 0,
  TreeConfig_Type_CLASSIC = 1,
  TreeConfig_Type_GREEDY_BUBBLE = 2,
  TreeConfig_Type_GREEDY_CLASSIC = 3,
  TreeConfig_Type_CRAWLING_BUBBLE = 4,
  TreeConfig_Type_BERTRAM_BUBBLE = 5,
  TreeConfig_Type_RBT = 6,
  TreeConfig_Type_GRBT = 7
};
bool TreeConfig_Type_IsValid(int value);
const TreeConfig_Type TreeConfig_Type_Type_MIN = TreeConfig_Type_BUBBLE;
const TreeConfig_Type TreeConfig_Type_Type_MAX = TreeConfig_Type_GRBT;
const int TreeConfig_Type_Type_ARRAYSIZE = TreeConfig_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* TreeConfig_Type_descriptor();
inline const ::std::string& TreeConfig_Type_Name(TreeConfig_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    TreeConfig_Type_descriptor(), value);
}
inline bool TreeConfig_Type_Parse(
    const ::std::string& name, TreeConfig_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TreeConfig_Type>(
    TreeConfig_Type_descriptor(), name, value);
}
// ===================================================================

class Point : public ::google::protobuf::Message {
 public:
  Point();
  virtual ~Point();

  Point(const Point& from);

  inline Point& operator=(const Point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Point& default_instance();

  void Swap(Point* other);

  // implements Message ----------------------------------------------

  Point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Point& from);
  void MergeFrom(const Point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated double q = 1;
  inline int q_size() const;
  inline void clear_q();
  static const int kQFieldNumber = 1;
  inline double q(int index) const;
  inline void set_q(int index, double value);
  inline void add_q(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      q() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_q();

  // @@protoc_insertion_point(class_scope:com.ademovic.bubblesmp.Point)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< double > q_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static Point* default_instance_;
};
// -------------------------------------------------------------------

class TreeConfig : public ::google::protobuf::Message {
 public:
  TreeConfig();
  virtual ~TreeConfig();

  TreeConfig(const TreeConfig& from);

  inline TreeConfig& operator=(const TreeConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TreeConfig& default_instance();

  void Swap(TreeConfig* other);

  // implements Message ----------------------------------------------

  TreeConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TreeConfig& from);
  void MergeFrom(const TreeConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef TreeConfig_Type Type;
  static const Type BUBBLE = TreeConfig_Type_BUBBLE;
  static const Type CLASSIC = TreeConfig_Type_CLASSIC;
  static const Type GREEDY_BUBBLE = TreeConfig_Type_GREEDY_BUBBLE;
  static const Type GREEDY_CLASSIC = TreeConfig_Type_GREEDY_CLASSIC;
  static const Type CRAWLING_BUBBLE = TreeConfig_Type_CRAWLING_BUBBLE;
  static const Type BERTRAM_BUBBLE = TreeConfig_Type_BERTRAM_BUBBLE;
  static const Type RBT = TreeConfig_Type_RBT;
  static const Type GRBT = TreeConfig_Type_GRBT;
  static inline bool Type_IsValid(int value) {
    return TreeConfig_Type_IsValid(value);
  }
  static const Type Type_MIN =
    TreeConfig_Type_Type_MIN;
  static const Type Type_MAX =
    TreeConfig_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    TreeConfig_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return TreeConfig_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return TreeConfig_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return TreeConfig_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.ademovic.bubblesmp.TreeConfig.Type type = 1 [default = BUBBLE];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::ademovic::bubblesmp::TreeConfig_Type type() const;
  inline void set_type(::com::ademovic::bubblesmp::TreeConfig_Type value);

  // optional uint32 bubbles_per_extend = 8 [default = 25];
  inline bool has_bubbles_per_extend() const;
  inline void clear_bubbles_per_extend();
  static const int kBubblesPerExtendFieldNumber = 8;
  inline ::google::protobuf::uint32 bubbles_per_extend() const;
  inline void set_bubbles_per_extend(::google::protobuf::uint32 value);

  // optional double min_bubble_reach = 9 [default = 2];
  inline bool has_min_bubble_reach() const;
  inline void clear_min_bubble_reach();
  static const int kMinBubbleReachFieldNumber = 9;
  inline double min_bubble_reach() const;
  inline void set_min_bubble_reach(double value);

  // optional double max_bubble_gap = 10 [default = 0.4];
  inline bool has_max_bubble_gap() const;
  inline void clear_max_bubble_gap();
  static const int kMaxBubbleGapFieldNumber = 10;
  inline double max_bubble_gap() const;
  inline void set_max_bubble_gap(double value);

  // optional double bubble_extend = 11 [default = 96];
  inline bool has_bubble_extend() const;
  inline void clear_bubble_extend();
  static const int kBubbleExtendFieldNumber = 11;
  inline double bubble_extend() const;
  inline void set_bubble_extend(double value);

  // optional bool use_extended_bubbles = 12 [default = true];
  inline bool has_use_extended_bubbles() const;
  inline void clear_use_extended_bubbles();
  static const int kUseExtendedBubblesFieldNumber = 12;
  inline bool use_extended_bubbles() const;
  inline void set_use_extended_bubbles(bool value);

  // optional uint32 max_bubbles_per_branch = 2 [default = 50];
  inline bool has_max_bubbles_per_branch() const;
  inline void clear_max_bubbles_per_branch();
  static const int kMaxBubblesPerBranchFieldNumber = 2;
  inline ::google::protobuf::uint32 max_bubbles_per_branch() const;
  inline void set_max_bubbles_per_branch(::google::protobuf::uint32 value);

  // optional uint32 max_binary_search_depth = 7 [default = 4];
  inline bool has_max_binary_search_depth() const;
  inline void clear_max_binary_search_depth();
  static const int kMaxBinarySearchDepthFieldNumber = 7;
  inline ::google::protobuf::uint32 max_binary_search_depth() const;
  inline void set_max_binary_search_depth(::google::protobuf::uint32 value);

  // optional double min_move_length = 3 [default = 0.9];
  inline bool has_min_move_length() const;
  inline void clear_min_move_length();
  static const int kMinMoveLengthFieldNumber = 3;
  inline double min_move_length() const;
  inline void set_min_move_length(double value);

  // optional double step_length = 4 [default = 10];
  inline bool has_step_length() const;
  inline void clear_step_length();
  static const int kStepLengthFieldNumber = 4;
  inline double step_length() const;
  inline void set_step_length(double value);

  // optional uint32 checks_per_step = 5 [default = 25];
  inline bool has_checks_per_step() const;
  inline void clear_checks_per_step();
  static const int kChecksPerStepFieldNumber = 5;
  inline ::google::protobuf::uint32 checks_per_step() const;
  inline void set_checks_per_step(::google::protobuf::uint32 value);

  // optional double s_min = 13 [default = 16];
  inline bool has_s_min() const;
  inline void clear_s_min();
  static const int kSMinFieldNumber = 13;
  inline double s_min() const;
  inline void set_s_min(double value);

  // optional uint32 checks_on_s_min = 14 [default = 40];
  inline bool has_checks_on_s_min() const;
  inline void clear_checks_on_s_min();
  static const int kChecksOnSMinFieldNumber = 14;
  inline ::google::protobuf::uint32 checks_on_s_min() const;
  inline void set_checks_on_s_min(::google::protobuf::uint32 value);

  // optional uint32 bur_size = 15 [default = 7];
  inline bool has_bur_size() const;
  inline void clear_bur_size();
  static const int kBurSizeFieldNumber = 15;
  inline ::google::protobuf::uint32 bur_size() const;
  inline void set_bur_size(::google::protobuf::uint32 value);

  // optional uint32 bur_threshold = 16 [default = 10];
  inline bool has_bur_threshold() const;
  inline void clear_bur_threshold();
  static const int kBurThresholdFieldNumber = 16;
  inline ::google::protobuf::uint32 bur_threshold() const;
  inline void set_bur_threshold(::google::protobuf::uint32 value);

  // optional uint32 number_of_extensions = 17 [default = 10];
  inline bool has_number_of_extensions() const;
  inline void clear_number_of_extensions();
  static const int kNumberOfExtensionsFieldNumber = 17;
  inline ::google::protobuf::uint32 number_of_extensions() const;
  inline void set_number_of_extensions(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:com.ademovic.bubblesmp.TreeConfig)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_bubbles_per_extend();
  inline void clear_has_bubbles_per_extend();
  inline void set_has_min_bubble_reach();
  inline void clear_has_min_bubble_reach();
  inline void set_has_max_bubble_gap();
  inline void clear_has_max_bubble_gap();
  inline void set_has_bubble_extend();
  inline void clear_has_bubble_extend();
  inline void set_has_use_extended_bubbles();
  inline void clear_has_use_extended_bubbles();
  inline void set_has_max_bubbles_per_branch();
  inline void clear_has_max_bubbles_per_branch();
  inline void set_has_max_binary_search_depth();
  inline void clear_has_max_binary_search_depth();
  inline void set_has_min_move_length();
  inline void clear_has_min_move_length();
  inline void set_has_step_length();
  inline void clear_has_step_length();
  inline void set_has_checks_per_step();
  inline void clear_has_checks_per_step();
  inline void set_has_s_min();
  inline void clear_has_s_min();
  inline void set_has_checks_on_s_min();
  inline void clear_has_checks_on_s_min();
  inline void set_has_bur_size();
  inline void clear_has_bur_size();
  inline void set_has_bur_threshold();
  inline void clear_has_bur_threshold();
  inline void set_has_number_of_extensions();
  inline void clear_has_number_of_extensions();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int type_;
  ::google::protobuf::uint32 bubbles_per_extend_;
  double min_bubble_reach_;
  double max_bubble_gap_;
  double bubble_extend_;
  bool use_extended_bubbles_;
  ::google::protobuf::uint32 max_bubbles_per_branch_;
  double min_move_length_;
  ::google::protobuf::uint32 max_binary_search_depth_;
  ::google::protobuf::uint32 checks_per_step_;
  double step_length_;
  double s_min_;
  ::google::protobuf::uint32 checks_on_s_min_;
  ::google::protobuf::uint32 bur_size_;
  ::google::protobuf::uint32 bur_threshold_;
  ::google::protobuf::uint32 number_of_extensions_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TreeConfig* default_instance_;
};
// -------------------------------------------------------------------

class TaskConfig : public ::google::protobuf::Message {
 public:
  TaskConfig();
  virtual ~TaskConfig();

  TaskConfig(const TaskConfig& from);

  inline TaskConfig& operator=(const TaskConfig& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskConfig& default_instance();

  void Swap(TaskConfig* other);

  // implements Message ----------------------------------------------

  TaskConfig* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskConfig& from);
  void MergeFrom(const TaskConfig& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .com.ademovic.bubblesmp.environment.EnvironmentConfig environment = 1;
  inline bool has_environment() const;
  inline void clear_environment();
  static const int kEnvironmentFieldNumber = 1;
  inline const ::com::ademovic::bubblesmp::environment::EnvironmentConfig& environment() const;
  inline ::com::ademovic::bubblesmp::environment::EnvironmentConfig* mutable_environment();
  inline ::com::ademovic::bubblesmp::environment::EnvironmentConfig* release_environment();
  inline void set_allocated_environment(::com::ademovic::bubblesmp::environment::EnvironmentConfig* environment);

  // optional .com.ademovic.bubblesmp.generators.GeneratorSettings generator = 2;
  inline bool has_generator() const;
  inline void clear_generator();
  static const int kGeneratorFieldNumber = 2;
  inline const ::com::ademovic::bubblesmp::generators::GeneratorSettings& generator() const;
  inline ::com::ademovic::bubblesmp::generators::GeneratorSettings* mutable_generator();
  inline ::com::ademovic::bubblesmp::generators::GeneratorSettings* release_generator();
  inline void set_allocated_generator(::com::ademovic::bubblesmp::generators::GeneratorSettings* generator);

  // optional .com.ademovic.bubblesmp.IndexSettings index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline const ::com::ademovic::bubblesmp::IndexSettings& index() const;
  inline ::com::ademovic::bubblesmp::IndexSettings* mutable_index();
  inline ::com::ademovic::bubblesmp::IndexSettings* release_index();
  inline void set_allocated_index(::com::ademovic::bubblesmp::IndexSettings* index);

  // optional .com.ademovic.bubblesmp.TreeConfig tree = 4;
  inline bool has_tree() const;
  inline void clear_tree();
  static const int kTreeFieldNumber = 4;
  inline const ::com::ademovic::bubblesmp::TreeConfig& tree() const;
  inline ::com::ademovic::bubblesmp::TreeConfig* mutable_tree();
  inline ::com::ademovic::bubblesmp::TreeConfig* release_tree();
  inline void set_allocated_tree(::com::ademovic::bubblesmp::TreeConfig* tree);

  // optional .com.ademovic.bubblesmp.Point source = 5;
  inline bool has_source() const;
  inline void clear_source();
  static const int kSourceFieldNumber = 5;
  inline const ::com::ademovic::bubblesmp::Point& source() const;
  inline ::com::ademovic::bubblesmp::Point* mutable_source();
  inline ::com::ademovic::bubblesmp::Point* release_source();
  inline void set_allocated_source(::com::ademovic::bubblesmp::Point* source);

  // optional .com.ademovic.bubblesmp.Point destination = 6;
  inline bool has_destination() const;
  inline void clear_destination();
  static const int kDestinationFieldNumber = 6;
  inline const ::com::ademovic::bubblesmp::Point& destination() const;
  inline ::com::ademovic::bubblesmp::Point* mutable_destination();
  inline ::com::ademovic::bubblesmp::Point* release_destination();
  inline void set_allocated_destination(::com::ademovic::bubblesmp::Point* destination);

  // @@protoc_insertion_point(class_scope:com.ademovic.bubblesmp.TaskConfig)
 private:
  inline void set_has_environment();
  inline void clear_has_environment();
  inline void set_has_generator();
  inline void clear_has_generator();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_tree();
  inline void clear_has_tree();
  inline void set_has_source();
  inline void clear_has_source();
  inline void set_has_destination();
  inline void clear_has_destination();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::ademovic::bubblesmp::environment::EnvironmentConfig* environment_;
  ::com::ademovic::bubblesmp::generators::GeneratorSettings* generator_;
  ::com::ademovic::bubblesmp::IndexSettings* index_;
  ::com::ademovic::bubblesmp::TreeConfig* tree_;
  ::com::ademovic::bubblesmp::Point* source_;
  ::com::ademovic::bubblesmp::Point* destination_;
  friend void  protobuf_AddDesc_task_2eproto();
  friend void protobuf_AssignDesc_task_2eproto();
  friend void protobuf_ShutdownFile_task_2eproto();

  void InitAsDefaultInstance();
  static TaskConfig* default_instance_;
};
// ===================================================================


// ===================================================================

// Point

// repeated double q = 1;
inline int Point::q_size() const {
  return q_.size();
}
inline void Point::clear_q() {
  q_.Clear();
}
inline double Point::q(int index) const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.Point.q)
  return q_.Get(index);
}
inline void Point::set_q(int index, double value) {
  q_.Set(index, value);
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.Point.q)
}
inline void Point::add_q(double value) {
  q_.Add(value);
  // @@protoc_insertion_point(field_add:com.ademovic.bubblesmp.Point.q)
}
inline const ::google::protobuf::RepeatedField< double >&
Point::q() const {
  // @@protoc_insertion_point(field_list:com.ademovic.bubblesmp.Point.q)
  return q_;
}
inline ::google::protobuf::RepeatedField< double >*
Point::mutable_q() {
  // @@protoc_insertion_point(field_mutable_list:com.ademovic.bubblesmp.Point.q)
  return &q_;
}

// -------------------------------------------------------------------

// TreeConfig

// optional .com.ademovic.bubblesmp.TreeConfig.Type type = 1 [default = BUBBLE];
inline bool TreeConfig::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeConfig::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TreeConfig::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TreeConfig::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::com::ademovic::bubblesmp::TreeConfig_Type TreeConfig::type() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.type)
  return static_cast< ::com::ademovic::bubblesmp::TreeConfig_Type >(type_);
}
inline void TreeConfig::set_type(::com::ademovic::bubblesmp::TreeConfig_Type value) {
  assert(::com::ademovic::bubblesmp::TreeConfig_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.type)
}

// optional uint32 bubbles_per_extend = 8 [default = 25];
inline bool TreeConfig::has_bubbles_per_extend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreeConfig::set_has_bubbles_per_extend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TreeConfig::clear_has_bubbles_per_extend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TreeConfig::clear_bubbles_per_extend() {
  bubbles_per_extend_ = 25u;
  clear_has_bubbles_per_extend();
}
inline ::google::protobuf::uint32 TreeConfig::bubbles_per_extend() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.bubbles_per_extend)
  return bubbles_per_extend_;
}
inline void TreeConfig::set_bubbles_per_extend(::google::protobuf::uint32 value) {
  set_has_bubbles_per_extend();
  bubbles_per_extend_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.bubbles_per_extend)
}

// optional double min_bubble_reach = 9 [default = 2];
inline bool TreeConfig::has_min_bubble_reach() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeConfig::set_has_min_bubble_reach() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TreeConfig::clear_has_min_bubble_reach() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TreeConfig::clear_min_bubble_reach() {
  min_bubble_reach_ = 2;
  clear_has_min_bubble_reach();
}
inline double TreeConfig::min_bubble_reach() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.min_bubble_reach)
  return min_bubble_reach_;
}
inline void TreeConfig::set_min_bubble_reach(double value) {
  set_has_min_bubble_reach();
  min_bubble_reach_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.min_bubble_reach)
}

// optional double max_bubble_gap = 10 [default = 0.4];
inline bool TreeConfig::has_max_bubble_gap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TreeConfig::set_has_max_bubble_gap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TreeConfig::clear_has_max_bubble_gap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TreeConfig::clear_max_bubble_gap() {
  max_bubble_gap_ = 0.4;
  clear_has_max_bubble_gap();
}
inline double TreeConfig::max_bubble_gap() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.max_bubble_gap)
  return max_bubble_gap_;
}
inline void TreeConfig::set_max_bubble_gap(double value) {
  set_has_max_bubble_gap();
  max_bubble_gap_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.max_bubble_gap)
}

// optional double bubble_extend = 11 [default = 96];
inline bool TreeConfig::has_bubble_extend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreeConfig::set_has_bubble_extend() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TreeConfig::clear_has_bubble_extend() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TreeConfig::clear_bubble_extend() {
  bubble_extend_ = 96;
  clear_has_bubble_extend();
}
inline double TreeConfig::bubble_extend() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.bubble_extend)
  return bubble_extend_;
}
inline void TreeConfig::set_bubble_extend(double value) {
  set_has_bubble_extend();
  bubble_extend_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.bubble_extend)
}

// optional bool use_extended_bubbles = 12 [default = true];
inline bool TreeConfig::has_use_extended_bubbles() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TreeConfig::set_has_use_extended_bubbles() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TreeConfig::clear_has_use_extended_bubbles() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TreeConfig::clear_use_extended_bubbles() {
  use_extended_bubbles_ = true;
  clear_has_use_extended_bubbles();
}
inline bool TreeConfig::use_extended_bubbles() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.use_extended_bubbles)
  return use_extended_bubbles_;
}
inline void TreeConfig::set_use_extended_bubbles(bool value) {
  set_has_use_extended_bubbles();
  use_extended_bubbles_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.use_extended_bubbles)
}

// optional uint32 max_bubbles_per_branch = 2 [default = 50];
inline bool TreeConfig::has_max_bubbles_per_branch() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TreeConfig::set_has_max_bubbles_per_branch() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TreeConfig::clear_has_max_bubbles_per_branch() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TreeConfig::clear_max_bubbles_per_branch() {
  max_bubbles_per_branch_ = 50u;
  clear_has_max_bubbles_per_branch();
}
inline ::google::protobuf::uint32 TreeConfig::max_bubbles_per_branch() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.max_bubbles_per_branch)
  return max_bubbles_per_branch_;
}
inline void TreeConfig::set_max_bubbles_per_branch(::google::protobuf::uint32 value) {
  set_has_max_bubbles_per_branch();
  max_bubbles_per_branch_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.max_bubbles_per_branch)
}

// optional uint32 max_binary_search_depth = 7 [default = 4];
inline bool TreeConfig::has_max_binary_search_depth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TreeConfig::set_has_max_binary_search_depth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TreeConfig::clear_has_max_binary_search_depth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TreeConfig::clear_max_binary_search_depth() {
  max_binary_search_depth_ = 4u;
  clear_has_max_binary_search_depth();
}
inline ::google::protobuf::uint32 TreeConfig::max_binary_search_depth() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.max_binary_search_depth)
  return max_binary_search_depth_;
}
inline void TreeConfig::set_max_binary_search_depth(::google::protobuf::uint32 value) {
  set_has_max_binary_search_depth();
  max_binary_search_depth_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.max_binary_search_depth)
}

// optional double min_move_length = 3 [default = 0.9];
inline bool TreeConfig::has_min_move_length() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TreeConfig::set_has_min_move_length() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TreeConfig::clear_has_min_move_length() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TreeConfig::clear_min_move_length() {
  min_move_length_ = 0.9;
  clear_has_min_move_length();
}
inline double TreeConfig::min_move_length() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.min_move_length)
  return min_move_length_;
}
inline void TreeConfig::set_min_move_length(double value) {
  set_has_min_move_length();
  min_move_length_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.min_move_length)
}

// optional double step_length = 4 [default = 10];
inline bool TreeConfig::has_step_length() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TreeConfig::set_has_step_length() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TreeConfig::clear_has_step_length() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TreeConfig::clear_step_length() {
  step_length_ = 10;
  clear_has_step_length();
}
inline double TreeConfig::step_length() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.step_length)
  return step_length_;
}
inline void TreeConfig::set_step_length(double value) {
  set_has_step_length();
  step_length_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.step_length)
}

// optional uint32 checks_per_step = 5 [default = 25];
inline bool TreeConfig::has_checks_per_step() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TreeConfig::set_has_checks_per_step() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TreeConfig::clear_has_checks_per_step() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TreeConfig::clear_checks_per_step() {
  checks_per_step_ = 25u;
  clear_has_checks_per_step();
}
inline ::google::protobuf::uint32 TreeConfig::checks_per_step() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.checks_per_step)
  return checks_per_step_;
}
inline void TreeConfig::set_checks_per_step(::google::protobuf::uint32 value) {
  set_has_checks_per_step();
  checks_per_step_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.checks_per_step)
}

// optional double s_min = 13 [default = 16];
inline bool TreeConfig::has_s_min() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TreeConfig::set_has_s_min() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TreeConfig::clear_has_s_min() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TreeConfig::clear_s_min() {
  s_min_ = 16;
  clear_has_s_min();
}
inline double TreeConfig::s_min() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.s_min)
  return s_min_;
}
inline void TreeConfig::set_s_min(double value) {
  set_has_s_min();
  s_min_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.s_min)
}

// optional uint32 checks_on_s_min = 14 [default = 40];
inline bool TreeConfig::has_checks_on_s_min() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TreeConfig::set_has_checks_on_s_min() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TreeConfig::clear_has_checks_on_s_min() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TreeConfig::clear_checks_on_s_min() {
  checks_on_s_min_ = 40u;
  clear_has_checks_on_s_min();
}
inline ::google::protobuf::uint32 TreeConfig::checks_on_s_min() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.checks_on_s_min)
  return checks_on_s_min_;
}
inline void TreeConfig::set_checks_on_s_min(::google::protobuf::uint32 value) {
  set_has_checks_on_s_min();
  checks_on_s_min_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.checks_on_s_min)
}

// optional uint32 bur_size = 15 [default = 7];
inline bool TreeConfig::has_bur_size() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TreeConfig::set_has_bur_size() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TreeConfig::clear_has_bur_size() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TreeConfig::clear_bur_size() {
  bur_size_ = 7u;
  clear_has_bur_size();
}
inline ::google::protobuf::uint32 TreeConfig::bur_size() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.bur_size)
  return bur_size_;
}
inline void TreeConfig::set_bur_size(::google::protobuf::uint32 value) {
  set_has_bur_size();
  bur_size_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.bur_size)
}

// optional uint32 bur_threshold = 16 [default = 10];
inline bool TreeConfig::has_bur_threshold() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TreeConfig::set_has_bur_threshold() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TreeConfig::clear_has_bur_threshold() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TreeConfig::clear_bur_threshold() {
  bur_threshold_ = 10u;
  clear_has_bur_threshold();
}
inline ::google::protobuf::uint32 TreeConfig::bur_threshold() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.bur_threshold)
  return bur_threshold_;
}
inline void TreeConfig::set_bur_threshold(::google::protobuf::uint32 value) {
  set_has_bur_threshold();
  bur_threshold_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.bur_threshold)
}

// optional uint32 number_of_extensions = 17 [default = 10];
inline bool TreeConfig::has_number_of_extensions() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TreeConfig::set_has_number_of_extensions() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TreeConfig::clear_has_number_of_extensions() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TreeConfig::clear_number_of_extensions() {
  number_of_extensions_ = 10u;
  clear_has_number_of_extensions();
}
inline ::google::protobuf::uint32 TreeConfig::number_of_extensions() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TreeConfig.number_of_extensions)
  return number_of_extensions_;
}
inline void TreeConfig::set_number_of_extensions(::google::protobuf::uint32 value) {
  set_has_number_of_extensions();
  number_of_extensions_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.TreeConfig.number_of_extensions)
}

// -------------------------------------------------------------------

// TaskConfig

// optional .com.ademovic.bubblesmp.environment.EnvironmentConfig environment = 1;
inline bool TaskConfig::has_environment() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskConfig::set_has_environment() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskConfig::clear_has_environment() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskConfig::clear_environment() {
  if (environment_ != NULL) environment_->::com::ademovic::bubblesmp::environment::EnvironmentConfig::Clear();
  clear_has_environment();
}
inline const ::com::ademovic::bubblesmp::environment::EnvironmentConfig& TaskConfig::environment() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TaskConfig.environment)
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
inline ::com::ademovic::bubblesmp::environment::EnvironmentConfig* TaskConfig::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) environment_ = new ::com::ademovic::bubblesmp::environment::EnvironmentConfig;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.TaskConfig.environment)
  return environment_;
}
inline ::com::ademovic::bubblesmp::environment::EnvironmentConfig* TaskConfig::release_environment() {
  clear_has_environment();
  ::com::ademovic::bubblesmp::environment::EnvironmentConfig* temp = environment_;
  environment_ = NULL;
  return temp;
}
inline void TaskConfig::set_allocated_environment(::com::ademovic::bubblesmp::environment::EnvironmentConfig* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.TaskConfig.environment)
}

// optional .com.ademovic.bubblesmp.generators.GeneratorSettings generator = 2;
inline bool TaskConfig::has_generator() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskConfig::set_has_generator() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskConfig::clear_has_generator() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskConfig::clear_generator() {
  if (generator_ != NULL) generator_->::com::ademovic::bubblesmp::generators::GeneratorSettings::Clear();
  clear_has_generator();
}
inline const ::com::ademovic::bubblesmp::generators::GeneratorSettings& TaskConfig::generator() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TaskConfig.generator)
  return generator_ != NULL ? *generator_ : *default_instance_->generator_;
}
inline ::com::ademovic::bubblesmp::generators::GeneratorSettings* TaskConfig::mutable_generator() {
  set_has_generator();
  if (generator_ == NULL) generator_ = new ::com::ademovic::bubblesmp::generators::GeneratorSettings;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.TaskConfig.generator)
  return generator_;
}
inline ::com::ademovic::bubblesmp::generators::GeneratorSettings* TaskConfig::release_generator() {
  clear_has_generator();
  ::com::ademovic::bubblesmp::generators::GeneratorSettings* temp = generator_;
  generator_ = NULL;
  return temp;
}
inline void TaskConfig::set_allocated_generator(::com::ademovic::bubblesmp::generators::GeneratorSettings* generator) {
  delete generator_;
  generator_ = generator;
  if (generator) {
    set_has_generator();
  } else {
    clear_has_generator();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.TaskConfig.generator)
}

// optional .com.ademovic.bubblesmp.IndexSettings index = 3;
inline bool TaskConfig::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskConfig::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskConfig::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskConfig::clear_index() {
  if (index_ != NULL) index_->::com::ademovic::bubblesmp::IndexSettings::Clear();
  clear_has_index();
}
inline const ::com::ademovic::bubblesmp::IndexSettings& TaskConfig::index() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TaskConfig.index)
  return index_ != NULL ? *index_ : *default_instance_->index_;
}
inline ::com::ademovic::bubblesmp::IndexSettings* TaskConfig::mutable_index() {
  set_has_index();
  if (index_ == NULL) index_ = new ::com::ademovic::bubblesmp::IndexSettings;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.TaskConfig.index)
  return index_;
}
inline ::com::ademovic::bubblesmp::IndexSettings* TaskConfig::release_index() {
  clear_has_index();
  ::com::ademovic::bubblesmp::IndexSettings* temp = index_;
  index_ = NULL;
  return temp;
}
inline void TaskConfig::set_allocated_index(::com::ademovic::bubblesmp::IndexSettings* index) {
  delete index_;
  index_ = index;
  if (index) {
    set_has_index();
  } else {
    clear_has_index();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.TaskConfig.index)
}

// optional .com.ademovic.bubblesmp.TreeConfig tree = 4;
inline bool TaskConfig::has_tree() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskConfig::set_has_tree() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskConfig::clear_has_tree() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskConfig::clear_tree() {
  if (tree_ != NULL) tree_->::com::ademovic::bubblesmp::TreeConfig::Clear();
  clear_has_tree();
}
inline const ::com::ademovic::bubblesmp::TreeConfig& TaskConfig::tree() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TaskConfig.tree)
  return tree_ != NULL ? *tree_ : *default_instance_->tree_;
}
inline ::com::ademovic::bubblesmp::TreeConfig* TaskConfig::mutable_tree() {
  set_has_tree();
  if (tree_ == NULL) tree_ = new ::com::ademovic::bubblesmp::TreeConfig;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.TaskConfig.tree)
  return tree_;
}
inline ::com::ademovic::bubblesmp::TreeConfig* TaskConfig::release_tree() {
  clear_has_tree();
  ::com::ademovic::bubblesmp::TreeConfig* temp = tree_;
  tree_ = NULL;
  return temp;
}
inline void TaskConfig::set_allocated_tree(::com::ademovic::bubblesmp::TreeConfig* tree) {
  delete tree_;
  tree_ = tree;
  if (tree) {
    set_has_tree();
  } else {
    clear_has_tree();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.TaskConfig.tree)
}

// optional .com.ademovic.bubblesmp.Point source = 5;
inline bool TaskConfig::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskConfig::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskConfig::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskConfig::clear_source() {
  if (source_ != NULL) source_->::com::ademovic::bubblesmp::Point::Clear();
  clear_has_source();
}
inline const ::com::ademovic::bubblesmp::Point& TaskConfig::source() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TaskConfig.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
inline ::com::ademovic::bubblesmp::Point* TaskConfig::mutable_source() {
  set_has_source();
  if (source_ == NULL) source_ = new ::com::ademovic::bubblesmp::Point;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.TaskConfig.source)
  return source_;
}
inline ::com::ademovic::bubblesmp::Point* TaskConfig::release_source() {
  clear_has_source();
  ::com::ademovic::bubblesmp::Point* temp = source_;
  source_ = NULL;
  return temp;
}
inline void TaskConfig::set_allocated_source(::com::ademovic::bubblesmp::Point* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.TaskConfig.source)
}

// optional .com.ademovic.bubblesmp.Point destination = 6;
inline bool TaskConfig::has_destination() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskConfig::set_has_destination() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskConfig::clear_has_destination() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskConfig::clear_destination() {
  if (destination_ != NULL) destination_->::com::ademovic::bubblesmp::Point::Clear();
  clear_has_destination();
}
inline const ::com::ademovic::bubblesmp::Point& TaskConfig::destination() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.TaskConfig.destination)
  return destination_ != NULL ? *destination_ : *default_instance_->destination_;
}
inline ::com::ademovic::bubblesmp::Point* TaskConfig::mutable_destination() {
  set_has_destination();
  if (destination_ == NULL) destination_ = new ::com::ademovic::bubblesmp::Point;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.TaskConfig.destination)
  return destination_;
}
inline ::com::ademovic::bubblesmp::Point* TaskConfig::release_destination() {
  clear_has_destination();
  ::com::ademovic::bubblesmp::Point* temp = destination_;
  destination_ = NULL;
  return temp;
}
inline void TaskConfig::set_allocated_destination(::com::ademovic::bubblesmp::Point* destination) {
  delete destination_;
  destination_ = destination;
  if (destination) {
    set_has_destination();
  } else {
    clear_has_destination();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.TaskConfig.destination)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bubblesmp
}  // namespace ademovic
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::ademovic::bubblesmp::TreeConfig_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::ademovic::bubblesmp::TreeConfig_Type>() {
  return ::com::ademovic::bubblesmp::TreeConfig_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_task_2eproto__INCLUDED
