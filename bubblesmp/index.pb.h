// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bubblesmp/index.proto

#ifndef PROTOBUF_bubblesmp_2findex_2eproto__INCLUDED
#define PROTOBUF_bubblesmp_2findex_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace com {
namespace ademovic {
namespace bubblesmp {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_bubblesmp_2findex_2eproto();
void protobuf_AssignDesc_bubblesmp_2findex_2eproto();
void protobuf_ShutdownFile_bubblesmp_2findex_2eproto();

class IndexParams;
class SearchParams;
class IndexSettings;

enum IndexParams_CentersInit {
  IndexParams_CentersInit_RANDOM = 0,
  IndexParams_CentersInit_GONZALES = 1,
  IndexParams_CentersInit_KMEANSPP = 2
};
bool IndexParams_CentersInit_IsValid(int value);
const IndexParams_CentersInit IndexParams_CentersInit_CentersInit_MIN = IndexParams_CentersInit_RANDOM;
const IndexParams_CentersInit IndexParams_CentersInit_CentersInit_MAX = IndexParams_CentersInit_KMEANSPP;
const int IndexParams_CentersInit_CentersInit_ARRAYSIZE = IndexParams_CentersInit_CentersInit_MAX + 1;

const ::google::protobuf::EnumDescriptor* IndexParams_CentersInit_descriptor();
inline const ::std::string& IndexParams_CentersInit_Name(IndexParams_CentersInit value) {
  return ::google::protobuf::internal::NameOfEnum(
    IndexParams_CentersInit_descriptor(), value);
}
inline bool IndexParams_CentersInit_Parse(
    const ::std::string& name, IndexParams_CentersInit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IndexParams_CentersInit>(
    IndexParams_CentersInit_descriptor(), name, value);
}
enum IndexSettings_Type {
  IndexSettings_Type_LINEAR = 0,
  IndexSettings_Type_KD_TREE = 1,
  IndexSettings_Type_KD_TREE_SINGLE = 2,
  IndexSettings_Type_K_MEANS = 3,
  IndexSettings_Type_COMPOSITE = 4,
  IndexSettings_Type_LSH = 5,
  IndexSettings_Type_AUTOTUNED = 6
};
bool IndexSettings_Type_IsValid(int value);
const IndexSettings_Type IndexSettings_Type_Type_MIN = IndexSettings_Type_LINEAR;
const IndexSettings_Type IndexSettings_Type_Type_MAX = IndexSettings_Type_AUTOTUNED;
const int IndexSettings_Type_Type_ARRAYSIZE = IndexSettings_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* IndexSettings_Type_descriptor();
inline const ::std::string& IndexSettings_Type_Name(IndexSettings_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    IndexSettings_Type_descriptor(), value);
}
inline bool IndexSettings_Type_Parse(
    const ::std::string& name, IndexSettings_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<IndexSettings_Type>(
    IndexSettings_Type_descriptor(), name, value);
}
// ===================================================================

class IndexParams : public ::google::protobuf::Message {
 public:
  IndexParams();
  virtual ~IndexParams();

  IndexParams(const IndexParams& from);

  inline IndexParams& operator=(const IndexParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexParams& default_instance();

  void Swap(IndexParams* other);

  // implements Message ----------------------------------------------

  IndexParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexParams& from);
  void MergeFrom(const IndexParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IndexParams_CentersInit CentersInit;
  static const CentersInit RANDOM = IndexParams_CentersInit_RANDOM;
  static const CentersInit GONZALES = IndexParams_CentersInit_GONZALES;
  static const CentersInit KMEANSPP = IndexParams_CentersInit_KMEANSPP;
  static inline bool CentersInit_IsValid(int value) {
    return IndexParams_CentersInit_IsValid(value);
  }
  static const CentersInit CentersInit_MIN =
    IndexParams_CentersInit_CentersInit_MIN;
  static const CentersInit CentersInit_MAX =
    IndexParams_CentersInit_CentersInit_MAX;
  static const int CentersInit_ARRAYSIZE =
    IndexParams_CentersInit_CentersInit_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CentersInit_descriptor() {
    return IndexParams_CentersInit_descriptor();
  }
  static inline const ::std::string& CentersInit_Name(CentersInit value) {
    return IndexParams_CentersInit_Name(value);
  }
  static inline bool CentersInit_Parse(const ::std::string& name,
      CentersInit* value) {
    return IndexParams_CentersInit_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 trees = 1 [default = 4];
  inline bool has_trees() const;
  inline void clear_trees();
  static const int kTreesFieldNumber = 1;
  inline ::google::protobuf::int32 trees() const;
  inline void set_trees(::google::protobuf::int32 value);

  // optional int32 branching = 2 [default = 32];
  inline bool has_branching() const;
  inline void clear_branching();
  static const int kBranchingFieldNumber = 2;
  inline ::google::protobuf::int32 branching() const;
  inline void set_branching(::google::protobuf::int32 value);

  // optional int32 iterations = 3 [default = 11];
  inline bool has_iterations() const;
  inline void clear_iterations();
  static const int kIterationsFieldNumber = 3;
  inline ::google::protobuf::int32 iterations() const;
  inline void set_iterations(::google::protobuf::int32 value);

  // optional .com.ademovic.bubblesmp.IndexParams.CentersInit centers_init = 4 [default = RANDOM];
  inline bool has_centers_init() const;
  inline void clear_centers_init();
  static const int kCentersInitFieldNumber = 4;
  inline ::com::ademovic::bubblesmp::IndexParams_CentersInit centers_init() const;
  inline void set_centers_init(::com::ademovic::bubblesmp::IndexParams_CentersInit value);

  // optional float cb_index = 5 [default = 0.2];
  inline bool has_cb_index() const;
  inline void clear_cb_index();
  static const int kCbIndexFieldNumber = 5;
  inline float cb_index() const;
  inline void set_cb_index(float value);

  // optional int32 leaf_max_size = 6 [default = 10];
  inline bool has_leaf_max_size() const;
  inline void clear_leaf_max_size();
  static const int kLeafMaxSizeFieldNumber = 6;
  inline ::google::protobuf::int32 leaf_max_size() const;
  inline void set_leaf_max_size(::google::protobuf::int32 value);

  // optional uint32 table_number = 7 [default = 12];
  inline bool has_table_number() const;
  inline void clear_table_number();
  static const int kTableNumberFieldNumber = 7;
  inline ::google::protobuf::uint32 table_number() const;
  inline void set_table_number(::google::protobuf::uint32 value);

  // optional uint32 key_size = 8 [default = 20];
  inline bool has_key_size() const;
  inline void clear_key_size();
  static const int kKeySizeFieldNumber = 8;
  inline ::google::protobuf::uint32 key_size() const;
  inline void set_key_size(::google::protobuf::uint32 value);

  // optional uint32 multi_probe_level = 9 [default = 2];
  inline bool has_multi_probe_level() const;
  inline void clear_multi_probe_level();
  static const int kMultiProbeLevelFieldNumber = 9;
  inline ::google::protobuf::uint32 multi_probe_level() const;
  inline void set_multi_probe_level(::google::protobuf::uint32 value);

  // optional float target_precision = 10 [default = 0.9];
  inline bool has_target_precision() const;
  inline void clear_target_precision();
  static const int kTargetPrecisionFieldNumber = 10;
  inline float target_precision() const;
  inline void set_target_precision(float value);

  // optional float build_weight = 11 [default = 0.01];
  inline bool has_build_weight() const;
  inline void clear_build_weight();
  static const int kBuildWeightFieldNumber = 11;
  inline float build_weight() const;
  inline void set_build_weight(float value);

  // optional float memory_weight = 12 [default = 0];
  inline bool has_memory_weight() const;
  inline void clear_memory_weight();
  static const int kMemoryWeightFieldNumber = 12;
  inline float memory_weight() const;
  inline void set_memory_weight(float value);

  // optional float sample_fraction = 13 [default = 0.1];
  inline bool has_sample_fraction() const;
  inline void clear_sample_fraction();
  static const int kSampleFractionFieldNumber = 13;
  inline float sample_fraction() const;
  inline void set_sample_fraction(float value);

  // @@protoc_insertion_point(class_scope:com.ademovic.bubblesmp.IndexParams)
 private:
  inline void set_has_trees();
  inline void clear_has_trees();
  inline void set_has_branching();
  inline void clear_has_branching();
  inline void set_has_iterations();
  inline void clear_has_iterations();
  inline void set_has_centers_init();
  inline void clear_has_centers_init();
  inline void set_has_cb_index();
  inline void clear_has_cb_index();
  inline void set_has_leaf_max_size();
  inline void clear_has_leaf_max_size();
  inline void set_has_table_number();
  inline void clear_has_table_number();
  inline void set_has_key_size();
  inline void clear_has_key_size();
  inline void set_has_multi_probe_level();
  inline void clear_has_multi_probe_level();
  inline void set_has_target_precision();
  inline void clear_has_target_precision();
  inline void set_has_build_weight();
  inline void clear_has_build_weight();
  inline void set_has_memory_weight();
  inline void clear_has_memory_weight();
  inline void set_has_sample_fraction();
  inline void clear_has_sample_fraction();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 trees_;
  ::google::protobuf::int32 branching_;
  ::google::protobuf::int32 iterations_;
  int centers_init_;
  float cb_index_;
  ::google::protobuf::int32 leaf_max_size_;
  ::google::protobuf::uint32 table_number_;
  ::google::protobuf::uint32 key_size_;
  ::google::protobuf::uint32 multi_probe_level_;
  float target_precision_;
  float build_weight_;
  float memory_weight_;
  float sample_fraction_;
  friend void  protobuf_AddDesc_bubblesmp_2findex_2eproto();
  friend void protobuf_AssignDesc_bubblesmp_2findex_2eproto();
  friend void protobuf_ShutdownFile_bubblesmp_2findex_2eproto();

  void InitAsDefaultInstance();
  static IndexParams* default_instance_;
};
// -------------------------------------------------------------------

class SearchParams : public ::google::protobuf::Message {
 public:
  SearchParams();
  virtual ~SearchParams();

  SearchParams(const SearchParams& from);

  inline SearchParams& operator=(const SearchParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchParams& default_instance();

  void Swap(SearchParams* other);

  // implements Message ----------------------------------------------

  SearchParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SearchParams& from);
  void MergeFrom(const SearchParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 checks = 1 [default = 32];
  inline bool has_checks() const;
  inline void clear_checks();
  static const int kChecksFieldNumber = 1;
  inline ::google::protobuf::int32 checks() const;
  inline void set_checks(::google::protobuf::int32 value);

  // optional float eps = 2 [default = 0];
  inline bool has_eps() const;
  inline void clear_eps();
  static const int kEpsFieldNumber = 2;
  inline float eps() const;
  inline void set_eps(float value);

  // optional bool sorted = 3 [default = true];
  inline bool has_sorted() const;
  inline void clear_sorted();
  static const int kSortedFieldNumber = 3;
  inline bool sorted() const;
  inline void set_sorted(bool value);

  // optional int32 max_neighbors = 4 [default = -1];
  inline bool has_max_neighbors() const;
  inline void clear_max_neighbors();
  static const int kMaxNeighborsFieldNumber = 4;
  inline ::google::protobuf::int32 max_neighbors() const;
  inline void set_max_neighbors(::google::protobuf::int32 value);

  // optional bool use_heap = 5;
  inline bool has_use_heap() const;
  inline void clear_use_heap();
  static const int kUseHeapFieldNumber = 5;
  inline bool use_heap() const;
  inline void set_use_heap(bool value);

  // optional int32 cores = 6 [default = 0];
  inline bool has_cores() const;
  inline void clear_cores();
  static const int kCoresFieldNumber = 6;
  inline ::google::protobuf::int32 cores() const;
  inline void set_cores(::google::protobuf::int32 value);

  // optional bool matrices_in_gpu_ram = 7;
  inline bool has_matrices_in_gpu_ram() const;
  inline void clear_matrices_in_gpu_ram();
  static const int kMatricesInGpuRamFieldNumber = 7;
  inline bool matrices_in_gpu_ram() const;
  inline void set_matrices_in_gpu_ram(bool value);

  // @@protoc_insertion_point(class_scope:com.ademovic.bubblesmp.SearchParams)
 private:
  inline void set_has_checks();
  inline void clear_has_checks();
  inline void set_has_eps();
  inline void clear_has_eps();
  inline void set_has_sorted();
  inline void clear_has_sorted();
  inline void set_has_max_neighbors();
  inline void clear_has_max_neighbors();
  inline void set_has_use_heap();
  inline void clear_has_use_heap();
  inline void set_has_cores();
  inline void clear_has_cores();
  inline void set_has_matrices_in_gpu_ram();
  inline void clear_has_matrices_in_gpu_ram();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 checks_;
  float eps_;
  ::google::protobuf::int32 max_neighbors_;
  bool sorted_;
  bool use_heap_;
  bool matrices_in_gpu_ram_;
  ::google::protobuf::int32 cores_;
  friend void  protobuf_AddDesc_bubblesmp_2findex_2eproto();
  friend void protobuf_AssignDesc_bubblesmp_2findex_2eproto();
  friend void protobuf_ShutdownFile_bubblesmp_2findex_2eproto();

  void InitAsDefaultInstance();
  static SearchParams* default_instance_;
};
// -------------------------------------------------------------------

class IndexSettings : public ::google::protobuf::Message {
 public:
  IndexSettings();
  virtual ~IndexSettings();

  IndexSettings(const IndexSettings& from);

  inline IndexSettings& operator=(const IndexSettings& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IndexSettings& default_instance();

  void Swap(IndexSettings* other);

  // implements Message ----------------------------------------------

  IndexSettings* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const IndexSettings& from);
  void MergeFrom(const IndexSettings& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef IndexSettings_Type Type;
  static const Type LINEAR = IndexSettings_Type_LINEAR;
  static const Type KD_TREE = IndexSettings_Type_KD_TREE;
  static const Type KD_TREE_SINGLE = IndexSettings_Type_KD_TREE_SINGLE;
  static const Type K_MEANS = IndexSettings_Type_K_MEANS;
  static const Type COMPOSITE = IndexSettings_Type_COMPOSITE;
  static const Type LSH = IndexSettings_Type_LSH;
  static const Type AUTOTUNED = IndexSettings_Type_AUTOTUNED;
  static inline bool Type_IsValid(int value) {
    return IndexSettings_Type_IsValid(value);
  }
  static const Type Type_MIN =
    IndexSettings_Type_Type_MIN;
  static const Type Type_MAX =
    IndexSettings_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    IndexSettings_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return IndexSettings_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return IndexSettings_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return IndexSettings_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .com.ademovic.bubblesmp.IndexSettings.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::com::ademovic::bubblesmp::IndexSettings_Type type() const;
  inline void set_type(::com::ademovic::bubblesmp::IndexSettings_Type value);

  // optional .com.ademovic.bubblesmp.IndexParams index_params = 2;
  inline bool has_index_params() const;
  inline void clear_index_params();
  static const int kIndexParamsFieldNumber = 2;
  inline const ::com::ademovic::bubblesmp::IndexParams& index_params() const;
  inline ::com::ademovic::bubblesmp::IndexParams* mutable_index_params();
  inline ::com::ademovic::bubblesmp::IndexParams* release_index_params();
  inline void set_allocated_index_params(::com::ademovic::bubblesmp::IndexParams* index_params);

  // optional .com.ademovic.bubblesmp.SearchParams search_params = 3;
  inline bool has_search_params() const;
  inline void clear_search_params();
  static const int kSearchParamsFieldNumber = 3;
  inline const ::com::ademovic::bubblesmp::SearchParams& search_params() const;
  inline ::com::ademovic::bubblesmp::SearchParams* mutable_search_params();
  inline ::com::ademovic::bubblesmp::SearchParams* release_search_params();
  inline void set_allocated_search_params(::com::ademovic::bubblesmp::SearchParams* search_params);

  // @@protoc_insertion_point(class_scope:com.ademovic.bubblesmp.IndexSettings)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_index_params();
  inline void clear_has_index_params();
  inline void set_has_search_params();
  inline void clear_has_search_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::com::ademovic::bubblesmp::IndexParams* index_params_;
  ::com::ademovic::bubblesmp::SearchParams* search_params_;
  int type_;
  friend void  protobuf_AddDesc_bubblesmp_2findex_2eproto();
  friend void protobuf_AssignDesc_bubblesmp_2findex_2eproto();
  friend void protobuf_ShutdownFile_bubblesmp_2findex_2eproto();

  void InitAsDefaultInstance();
  static IndexSettings* default_instance_;
};
// ===================================================================


// ===================================================================

// IndexParams

// optional int32 trees = 1 [default = 4];
inline bool IndexParams::has_trees() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexParams::set_has_trees() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexParams::clear_has_trees() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexParams::clear_trees() {
  trees_ = 4;
  clear_has_trees();
}
inline ::google::protobuf::int32 IndexParams::trees() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.trees)
  return trees_;
}
inline void IndexParams::set_trees(::google::protobuf::int32 value) {
  set_has_trees();
  trees_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.trees)
}

// optional int32 branching = 2 [default = 32];
inline bool IndexParams::has_branching() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexParams::set_has_branching() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexParams::clear_has_branching() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexParams::clear_branching() {
  branching_ = 32;
  clear_has_branching();
}
inline ::google::protobuf::int32 IndexParams::branching() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.branching)
  return branching_;
}
inline void IndexParams::set_branching(::google::protobuf::int32 value) {
  set_has_branching();
  branching_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.branching)
}

// optional int32 iterations = 3 [default = 11];
inline bool IndexParams::has_iterations() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexParams::set_has_iterations() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexParams::clear_has_iterations() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexParams::clear_iterations() {
  iterations_ = 11;
  clear_has_iterations();
}
inline ::google::protobuf::int32 IndexParams::iterations() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.iterations)
  return iterations_;
}
inline void IndexParams::set_iterations(::google::protobuf::int32 value) {
  set_has_iterations();
  iterations_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.iterations)
}

// optional .com.ademovic.bubblesmp.IndexParams.CentersInit centers_init = 4 [default = RANDOM];
inline bool IndexParams::has_centers_init() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IndexParams::set_has_centers_init() {
  _has_bits_[0] |= 0x00000008u;
}
inline void IndexParams::clear_has_centers_init() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void IndexParams::clear_centers_init() {
  centers_init_ = 0;
  clear_has_centers_init();
}
inline ::com::ademovic::bubblesmp::IndexParams_CentersInit IndexParams::centers_init() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.centers_init)
  return static_cast< ::com::ademovic::bubblesmp::IndexParams_CentersInit >(centers_init_);
}
inline void IndexParams::set_centers_init(::com::ademovic::bubblesmp::IndexParams_CentersInit value) {
  assert(::com::ademovic::bubblesmp::IndexParams_CentersInit_IsValid(value));
  set_has_centers_init();
  centers_init_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.centers_init)
}

// optional float cb_index = 5 [default = 0.2];
inline bool IndexParams::has_cb_index() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void IndexParams::set_has_cb_index() {
  _has_bits_[0] |= 0x00000010u;
}
inline void IndexParams::clear_has_cb_index() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void IndexParams::clear_cb_index() {
  cb_index_ = 0.2f;
  clear_has_cb_index();
}
inline float IndexParams::cb_index() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.cb_index)
  return cb_index_;
}
inline void IndexParams::set_cb_index(float value) {
  set_has_cb_index();
  cb_index_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.cb_index)
}

// optional int32 leaf_max_size = 6 [default = 10];
inline bool IndexParams::has_leaf_max_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void IndexParams::set_has_leaf_max_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void IndexParams::clear_has_leaf_max_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void IndexParams::clear_leaf_max_size() {
  leaf_max_size_ = 10;
  clear_has_leaf_max_size();
}
inline ::google::protobuf::int32 IndexParams::leaf_max_size() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.leaf_max_size)
  return leaf_max_size_;
}
inline void IndexParams::set_leaf_max_size(::google::protobuf::int32 value) {
  set_has_leaf_max_size();
  leaf_max_size_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.leaf_max_size)
}

// optional uint32 table_number = 7 [default = 12];
inline bool IndexParams::has_table_number() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void IndexParams::set_has_table_number() {
  _has_bits_[0] |= 0x00000040u;
}
inline void IndexParams::clear_has_table_number() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void IndexParams::clear_table_number() {
  table_number_ = 12u;
  clear_has_table_number();
}
inline ::google::protobuf::uint32 IndexParams::table_number() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.table_number)
  return table_number_;
}
inline void IndexParams::set_table_number(::google::protobuf::uint32 value) {
  set_has_table_number();
  table_number_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.table_number)
}

// optional uint32 key_size = 8 [default = 20];
inline bool IndexParams::has_key_size() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void IndexParams::set_has_key_size() {
  _has_bits_[0] |= 0x00000080u;
}
inline void IndexParams::clear_has_key_size() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void IndexParams::clear_key_size() {
  key_size_ = 20u;
  clear_has_key_size();
}
inline ::google::protobuf::uint32 IndexParams::key_size() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.key_size)
  return key_size_;
}
inline void IndexParams::set_key_size(::google::protobuf::uint32 value) {
  set_has_key_size();
  key_size_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.key_size)
}

// optional uint32 multi_probe_level = 9 [default = 2];
inline bool IndexParams::has_multi_probe_level() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void IndexParams::set_has_multi_probe_level() {
  _has_bits_[0] |= 0x00000100u;
}
inline void IndexParams::clear_has_multi_probe_level() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void IndexParams::clear_multi_probe_level() {
  multi_probe_level_ = 2u;
  clear_has_multi_probe_level();
}
inline ::google::protobuf::uint32 IndexParams::multi_probe_level() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.multi_probe_level)
  return multi_probe_level_;
}
inline void IndexParams::set_multi_probe_level(::google::protobuf::uint32 value) {
  set_has_multi_probe_level();
  multi_probe_level_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.multi_probe_level)
}

// optional float target_precision = 10 [default = 0.9];
inline bool IndexParams::has_target_precision() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void IndexParams::set_has_target_precision() {
  _has_bits_[0] |= 0x00000200u;
}
inline void IndexParams::clear_has_target_precision() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void IndexParams::clear_target_precision() {
  target_precision_ = 0.9f;
  clear_has_target_precision();
}
inline float IndexParams::target_precision() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.target_precision)
  return target_precision_;
}
inline void IndexParams::set_target_precision(float value) {
  set_has_target_precision();
  target_precision_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.target_precision)
}

// optional float build_weight = 11 [default = 0.01];
inline bool IndexParams::has_build_weight() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void IndexParams::set_has_build_weight() {
  _has_bits_[0] |= 0x00000400u;
}
inline void IndexParams::clear_has_build_weight() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void IndexParams::clear_build_weight() {
  build_weight_ = 0.01f;
  clear_has_build_weight();
}
inline float IndexParams::build_weight() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.build_weight)
  return build_weight_;
}
inline void IndexParams::set_build_weight(float value) {
  set_has_build_weight();
  build_weight_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.build_weight)
}

// optional float memory_weight = 12 [default = 0];
inline bool IndexParams::has_memory_weight() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void IndexParams::set_has_memory_weight() {
  _has_bits_[0] |= 0x00000800u;
}
inline void IndexParams::clear_has_memory_weight() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void IndexParams::clear_memory_weight() {
  memory_weight_ = 0;
  clear_has_memory_weight();
}
inline float IndexParams::memory_weight() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.memory_weight)
  return memory_weight_;
}
inline void IndexParams::set_memory_weight(float value) {
  set_has_memory_weight();
  memory_weight_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.memory_weight)
}

// optional float sample_fraction = 13 [default = 0.1];
inline bool IndexParams::has_sample_fraction() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void IndexParams::set_has_sample_fraction() {
  _has_bits_[0] |= 0x00001000u;
}
inline void IndexParams::clear_has_sample_fraction() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void IndexParams::clear_sample_fraction() {
  sample_fraction_ = 0.1f;
  clear_has_sample_fraction();
}
inline float IndexParams::sample_fraction() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexParams.sample_fraction)
  return sample_fraction_;
}
inline void IndexParams::set_sample_fraction(float value) {
  set_has_sample_fraction();
  sample_fraction_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexParams.sample_fraction)
}

// -------------------------------------------------------------------

// SearchParams

// optional int32 checks = 1 [default = 32];
inline bool SearchParams::has_checks() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchParams::set_has_checks() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchParams::clear_has_checks() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchParams::clear_checks() {
  checks_ = 32;
  clear_has_checks();
}
inline ::google::protobuf::int32 SearchParams::checks() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.checks)
  return checks_;
}
inline void SearchParams::set_checks(::google::protobuf::int32 value) {
  set_has_checks();
  checks_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.checks)
}

// optional float eps = 2 [default = 0];
inline bool SearchParams::has_eps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchParams::set_has_eps() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchParams::clear_has_eps() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchParams::clear_eps() {
  eps_ = 0;
  clear_has_eps();
}
inline float SearchParams::eps() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.eps)
  return eps_;
}
inline void SearchParams::set_eps(float value) {
  set_has_eps();
  eps_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.eps)
}

// optional bool sorted = 3 [default = true];
inline bool SearchParams::has_sorted() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchParams::set_has_sorted() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchParams::clear_has_sorted() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchParams::clear_sorted() {
  sorted_ = true;
  clear_has_sorted();
}
inline bool SearchParams::sorted() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.sorted)
  return sorted_;
}
inline void SearchParams::set_sorted(bool value) {
  set_has_sorted();
  sorted_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.sorted)
}

// optional int32 max_neighbors = 4 [default = -1];
inline bool SearchParams::has_max_neighbors() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchParams::set_has_max_neighbors() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchParams::clear_has_max_neighbors() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchParams::clear_max_neighbors() {
  max_neighbors_ = -1;
  clear_has_max_neighbors();
}
inline ::google::protobuf::int32 SearchParams::max_neighbors() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.max_neighbors)
  return max_neighbors_;
}
inline void SearchParams::set_max_neighbors(::google::protobuf::int32 value) {
  set_has_max_neighbors();
  max_neighbors_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.max_neighbors)
}

// optional bool use_heap = 5;
inline bool SearchParams::has_use_heap() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SearchParams::set_has_use_heap() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SearchParams::clear_has_use_heap() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SearchParams::clear_use_heap() {
  use_heap_ = false;
  clear_has_use_heap();
}
inline bool SearchParams::use_heap() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.use_heap)
  return use_heap_;
}
inline void SearchParams::set_use_heap(bool value) {
  set_has_use_heap();
  use_heap_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.use_heap)
}

// optional int32 cores = 6 [default = 0];
inline bool SearchParams::has_cores() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SearchParams::set_has_cores() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SearchParams::clear_has_cores() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SearchParams::clear_cores() {
  cores_ = 0;
  clear_has_cores();
}
inline ::google::protobuf::int32 SearchParams::cores() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.cores)
  return cores_;
}
inline void SearchParams::set_cores(::google::protobuf::int32 value) {
  set_has_cores();
  cores_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.cores)
}

// optional bool matrices_in_gpu_ram = 7;
inline bool SearchParams::has_matrices_in_gpu_ram() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SearchParams::set_has_matrices_in_gpu_ram() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SearchParams::clear_has_matrices_in_gpu_ram() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SearchParams::clear_matrices_in_gpu_ram() {
  matrices_in_gpu_ram_ = false;
  clear_has_matrices_in_gpu_ram();
}
inline bool SearchParams::matrices_in_gpu_ram() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.SearchParams.matrices_in_gpu_ram)
  return matrices_in_gpu_ram_;
}
inline void SearchParams::set_matrices_in_gpu_ram(bool value) {
  set_has_matrices_in_gpu_ram();
  matrices_in_gpu_ram_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.SearchParams.matrices_in_gpu_ram)
}

// -------------------------------------------------------------------

// IndexSettings

// optional .com.ademovic.bubblesmp.IndexSettings.Type type = 1;
inline bool IndexSettings::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IndexSettings::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IndexSettings::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IndexSettings::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::com::ademovic::bubblesmp::IndexSettings_Type IndexSettings::type() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexSettings.type)
  return static_cast< ::com::ademovic::bubblesmp::IndexSettings_Type >(type_);
}
inline void IndexSettings::set_type(::com::ademovic::bubblesmp::IndexSettings_Type value) {
  assert(::com::ademovic::bubblesmp::IndexSettings_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:com.ademovic.bubblesmp.IndexSettings.type)
}

// optional .com.ademovic.bubblesmp.IndexParams index_params = 2;
inline bool IndexSettings::has_index_params() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IndexSettings::set_has_index_params() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IndexSettings::clear_has_index_params() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IndexSettings::clear_index_params() {
  if (index_params_ != NULL) index_params_->::com::ademovic::bubblesmp::IndexParams::Clear();
  clear_has_index_params();
}
inline const ::com::ademovic::bubblesmp::IndexParams& IndexSettings::index_params() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexSettings.index_params)
  return index_params_ != NULL ? *index_params_ : *default_instance_->index_params_;
}
inline ::com::ademovic::bubblesmp::IndexParams* IndexSettings::mutable_index_params() {
  set_has_index_params();
  if (index_params_ == NULL) index_params_ = new ::com::ademovic::bubblesmp::IndexParams;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.IndexSettings.index_params)
  return index_params_;
}
inline ::com::ademovic::bubblesmp::IndexParams* IndexSettings::release_index_params() {
  clear_has_index_params();
  ::com::ademovic::bubblesmp::IndexParams* temp = index_params_;
  index_params_ = NULL;
  return temp;
}
inline void IndexSettings::set_allocated_index_params(::com::ademovic::bubblesmp::IndexParams* index_params) {
  delete index_params_;
  index_params_ = index_params;
  if (index_params) {
    set_has_index_params();
  } else {
    clear_has_index_params();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.IndexSettings.index_params)
}

// optional .com.ademovic.bubblesmp.SearchParams search_params = 3;
inline bool IndexSettings::has_search_params() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IndexSettings::set_has_search_params() {
  _has_bits_[0] |= 0x00000004u;
}
inline void IndexSettings::clear_has_search_params() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void IndexSettings::clear_search_params() {
  if (search_params_ != NULL) search_params_->::com::ademovic::bubblesmp::SearchParams::Clear();
  clear_has_search_params();
}
inline const ::com::ademovic::bubblesmp::SearchParams& IndexSettings::search_params() const {
  // @@protoc_insertion_point(field_get:com.ademovic.bubblesmp.IndexSettings.search_params)
  return search_params_ != NULL ? *search_params_ : *default_instance_->search_params_;
}
inline ::com::ademovic::bubblesmp::SearchParams* IndexSettings::mutable_search_params() {
  set_has_search_params();
  if (search_params_ == NULL) search_params_ = new ::com::ademovic::bubblesmp::SearchParams;
  // @@protoc_insertion_point(field_mutable:com.ademovic.bubblesmp.IndexSettings.search_params)
  return search_params_;
}
inline ::com::ademovic::bubblesmp::SearchParams* IndexSettings::release_search_params() {
  clear_has_search_params();
  ::com::ademovic::bubblesmp::SearchParams* temp = search_params_;
  search_params_ = NULL;
  return temp;
}
inline void IndexSettings::set_allocated_search_params(::com::ademovic::bubblesmp::SearchParams* search_params) {
  delete search_params_;
  search_params_ = search_params;
  if (search_params) {
    set_has_search_params();
  } else {
    clear_has_search_params();
  }
  // @@protoc_insertion_point(field_set_allocated:com.ademovic.bubblesmp.IndexSettings.search_params)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace bubblesmp
}  // namespace ademovic
}  // namespace com

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::com::ademovic::bubblesmp::IndexParams_CentersInit> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::ademovic::bubblesmp::IndexParams_CentersInit>() {
  return ::com::ademovic::bubblesmp::IndexParams_CentersInit_descriptor();
}
template <> struct is_proto_enum< ::com::ademovic::bubblesmp::IndexSettings_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::com::ademovic::bubblesmp::IndexSettings_Type>() {
  return ::com::ademovic::bubblesmp::IndexSettings_Type_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bubblesmp_2findex_2eproto__INCLUDED
